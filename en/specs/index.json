{"Catalog":[{"Description":null,"Read More":{"Scheme":"https","Opaque":"","User":null,"Host":"hestia.zoralab.com","Path":"/en/specs/hestiagui/","RawPath":"","OmitHost":false,"ForceQuery":false,"RawQuery":"","Fragment":"","RawFragment":""},"Title":"hestiaGUI Technical Specification - ZORALab's Hestia"}],"Constants":[],"Description":"The technical specifications to refer when using ZORALab's Hestia. Easy-going, offline supported (via web PWA installation), and detailed oriented.","Designs":[{"Code":"","Description":"By design, ZORALab's Hestia carefully pick programming languages that do not\nsoley depending on its specialized distribution system alone for countering\ngeo-political and after-the-fact business changes nuisance threats (e.g.\nimplement restrictive geo-fencing or sudden steep price hike overnight without\nany notices). At the most upstream source (us), all supported technologies MUST\nbe distributable and re-distributable securely, online and offline with just a\nsimple '.zip' archive format.\n","Image":{},"Level":3,"Title":"Decentralized Distribution","URL":[]},{"Code":"","Description":"For ZORALab's Hestia, there are 2 orientations when it comes to designing\nalgorithm: (1) stream-oriented [S] focuses on extremely low memory footprint\nbut takes more time for processing; (2) memory-oriented [M] focuses on maximum\nmemory usage for faster speed. The default everyone practice is usually\nmemory-oriented where most people would care less about how much the memory is\nused in a 64-bit operating system. Microcontrollers and embedded folks however,\ntend to prefer stream-oriented due to the memory size limitations. Hence, all\nfunctions and methods **MUST** cater both stream-oriented and memory-oriented\nexecutions, whichever comes first.\n","Image":{},"Level":3,"Title":"Stream Vs. Memory","URL":[]},{"Code":"","Description":"One problem ZORALab's Hestia set to solve is to facilitate all functions and\nmethods by CPU Size (8-Bits, 16-bits, 24-bits, 32-bits, 64-bits, ...2048-bits).\nMost standard libraries are heavily geared towards 64-bits CPU, making it very\ndifficult to port into other CPU types like 8-bits and 16-bits. Therefore, to\ncombat scarcity, ZORALab's Hestia manually monomorphize all processing functions\nand methods giving the end users a choice rather than no-choice.\n","Image":{},"Level":3,"Title":"Monomorphize By CPU Size","URL":[]},{"Code":"PATTERN\n[Leaf]\n-\u003e\n[SuperCommon]/[Leaf]\n-------------\u003e\n[SuperCommon]/[Common]/[Leaf]\n----------------------\u003e\n\nEXAMPLES\nhestiaSTRING\n   ⮱ hestiaSTRING.M64_Sanitize\nhestiaNET/hestiaHTTP\n   ⮱ hestiaHTTP.Server\n   ⮱ hestiaHTTP.Client\nhestiaNET/hestiaHTTP/hestiaPWA\n   ⮱ hestiaPWA.ToAppJS\n   ⮱ hestiaPWA.ToAppManifest\n","Description":"For ZORALab's Hestia, ALWAYS LET USER TO ONLY IMPORT LEAF PACKAGES WHENEVER\nAVAILABLE. Build the leaf package to the point of self-sufficient manner. As for\nthe parent packages, **they are there to facilitate common utilities among the\nchildren packages**. Below is the import pattern:\n","Image":{},"Level":3,"Title":"Import Direction","URL":[]},{"Code":"「·PATTERN·」\nPACKAGE   = (x_)[origin][OUTPUT](_[VARIANT](_[SKU]))\nCONSTANT  = (X/x_)(priv_)[PURPOSE]_[NAME](_[VARIANT](_[SKU]))\nFUNCTION  = (X/x_)[[S/s]/[M/m]][CPU_BITS/N]_[Verb](_[VARIANT](_[SKU]))\nMETHOD    = (X/x_)[[S/s]/[M/m]][CPU_BITS/N]_[Verb](_[VARIANT](_[SKU]))\n\n\n「·LEGENDS·」\n()     = Optional\n[]     = Compulsory Variable Values\n/      = OR\nlower  = lowercase\nUPPER  = UPPERCASE\nX_, x_ = experimental\n\n\n\n\n---- EXAMPLES ----\n「·PACKAGE·」\nhestiaSTRING                   (hugo, go, nim)\nx_hestiaSTRING                 (hugo, go, nim)\nhestiaGUI/zoralabCORE          (hugo, go, nim)\nhestiaGUI/x_zoralabCORE        (hugo, go, nim)\nx_hestiaGUI/x_zoralabCORE      (hugo, go, nim)\n\n\n「·CONSTANT·」\nhestiaNET.TLS_1_3              (go-pub, nim-pub*)\nhestiaNET.X_TLS_1_3            (go-pub, nim-pub*)\nhestiaSYS.SYSTEM_NAME          (go-pub, nim-pub*)\nhestiaNET.priv_TLS_1_3         (go-priv, nim-priv)\nhestiaNET.priv_TLS_1_3         (go-priv, nim-priv)\nhestiaSYS.priv_SYSTEM_NAME     (go-priv, nim-priv)\n\n\n「·FUNCTION·」\nhestiaSTRING/Sanitize          (hugo-pub)\nhestiaSTRING.M64_Sanitize      (go-pub, nim-pub*)\nhestiaSTRING.S8_Sanitize       (go-pub, nim-pub*)\nhestiaSTRING.m64_Sanitize_V2   (go-priv, nim-priv)\nhestiaSTRING.s8_Sanitize_V2    (go-priv, nim-priv)\nhestiaSTRING.X_S8_Sanitize_V3  (go-pub, nim-pub*)\nhestiaSTRING.x_S8_Sanitize_V3  (go-priv, nim-priv)\nhestiaTESTING.SN_Format        (go-pub, nim-pub*)\nhestiaTESTING.MN_Format        (go-pub, nim-pub*)\n\n\n「·METHOD·」\nobj.M64_Sanitize               (go-pub, nim-pub*)\nobj.S8_Sanitize                (go-pub, nim-pub*)\nobj.m64_Sanitize_V2            (go-priv, nim-priv)\nobj.s8_Sanitize_V2             (go-priv, nim-priv)\nobj.X_S8_Sanitize_V3           (go-pub, nim-pub*)\nobj.x_S8_Sanitize_V3           (go-priv, nim-priv)\n","Description":"To comply with the import direction above and to avoid conflicting with the\nstandard libraries for facilitating a good experience of inter-operability,\nZORALab's Hestia employs its own naming convention across all supported\ntechnologies. We are still using Go's Titlecase as export indicator\nwhile Nim will just append its required astrisk at the end. ZORALab's Hestia\nnaming convention follow this pattern:\n","Image":{},"Level":3,"Title":"Naming Convention","URL":[]},{"Code":"","Description":"Error string returning as practiced in Go is actually quite expensive when\ndeployed in low memory footprint environment. Hence, we only use back the\nconventional  internal 'hestiaERROR' error codes (2 bytes) instead. Also,\nDO NOT PANIC. All functions and methods must be as deterministic as possible.\nThe lesser the abstraction, the better.\n","Image":{},"Level":3,"Title":"Error Code and No Panic","URL":[]},{"Code":"","Description":"Generics is only serving 1 specific type of meta-programming and\nmonomorphization. The problem is that at each cpu size, the monomorphic\nalgorithm can be very different and in most cases generics can't cater such\ncapability. THEREFORE, DO NOT USE IT. If the language provides macro system,\nuse that instead.\n","Image":{},"Level":3,"Title":"Use Macro and Avoid Generics","URL":[]},{"Code":"Add\nAppend\nBegin\nCopy\nDelete\nDivide\nEnd\nIndex(VARIANT)\nInsert(VARIANT)\nJoin\nLength\nMinus\nModulus\nMultiply\nNext\nParse[OBJECT]\nPop\nPrepend\nPrevious\nReplace(VARIANT)\nReserve\nSanitize\nScan\nSearch\nSort(VARIANT)\nSplit(VARIANT)\nString\nTo[OBJECT]\nValidate(VARIANT)\nZero\n\n\n「·LEGENDS·」\n()     = Optional\n[]     = Compulsory Variable Values\n","Description":"Since the package is output oriented: package function by default and method\nwhenever makes sense for duck-typing and associated processing\n(e.g. interfaces). The most important job is getting them documented. Among\nknown common names (or verbs) are:\n","Image":{},"Level":3,"Title":"Function vs. Method","URL":[]},{"Code":"","Description":"All packages shall be usable in WASM. Do not let user to mess with Javascript\nwhen used including UI rendering (that's what the library for).\n","Image":{},"Level":3,"Title":"WASM Capable","URL":[]}],"Functions":[],"ObjectiveAndPurposes":[{"Code":"","Description":"The goal is to offer the use of software libraries in a reliable and safe manner\nnot just from programming languages themselves but also its ecosystem and\nexternal threats like geo-politics or supply chain.\n","Image":{},"Level":3,"Title":"Safe Use of Software Libraries","URL":[]}],"Title":"ZORALab's Hestia Technical Specifications","Types":[],"Variables":[]}