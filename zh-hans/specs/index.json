{"创史来历":[{"URL":[],"代码":"","图像":{},"大纲":"主要目的是要供应不只是代码语言运用危机而包括生态系统和防止外部威胁地安全运用代码\n库。\n","层度":3,"标题":"安全运用代码库"}],"功能":[],"变化值":[],"固定值":[],"大纲":"那为了运用ZORALab赫斯提亚的科技规范文件。 随和、支持离线（通过PWA安装）和非常注重细节的。","数码构架":[],"标题":"ZORALab赫斯提亚科技规范","菜单":[{"了解更多":{"Scheme":"https","Opaque":"","User":null,"Host":"hestia.zoralab.com","Path":"/zh-hans/specs/hestiagui/","RawPath":"","OmitHost":false,"ForceQuery":false,"RawQuery":"","Fragment":"","RawFragment":""},"大纲":null,"标题":"hestiaGUI科技规范 - ZORALab赫斯提亚"}],"设计":[{"URL":[],"代码":"","图像":{},"大纲":"根据ZORALab赫斯提亚设计，我们是为了防止地缘政治和事后的肮脏诡计带来的无畏无聊的\n麻烦而很小心地选出我们支持的代码语言。在选择中，我们是检验它们不单一靠自己的中心\n化型方式分发软件包。在最高的开源（我们），所以支持的科技都可以不管上线或离线地\n通过一个简单的'.zip'格式无中心化分发。\n","层度":3,"标题":"网络HTML+CSS优先"},{"URL":[],"代码":"","图像":{},"大纲":"在ZORALab赫斯提亚设计算法，基本上有2种方式：（1）流动式[S]专注于运用非常少的记忆\n空间但可以用长一点的时间来完成任务。（2）记忆式[M]专注于运用多记忆空间来快速地把\n任务完成。通常大多数的开发者是建设记忆式的计算法（设计时是没有顾虑到运用多少记忆\n空间）。在微型控制器和嵌入式的世界里，由于记忆空间通常是实在太小了，多数人都会使\n用流动式。如此，ZORALab赫斯提亚所写的功能和运作方法**一定**要双双供应记忆式和流\n动式的方式以先到者为准。\n","层度":3,"标题":"流动式vs记忆式"},{"URL":[],"代码":"","图像":{},"大纲":"有一个问题ZORALab赫斯提亚一定要解决的是能供应各种不同的中央处理器的位大小（如：\n8-Bits、16-Bits、24-Bits、32-Bits、64-Bits、...2048-Bits）功能。多数的代码库是为\n64-Bits的中央处理器而写出。这把功能移植工作给其他位大小中央处理器非常困难和复杂。\n为了对抗这稀缺性的问题，ZORALab赫斯提亚会手动地通过中央处理器的位大小把所有供应\n的功能单态化好让顾客有个选择总好过没有选择。\n","层度":3,"标题":"通过中央处理器的位大小单态化"},{"URL":[],"代码":"PATTERN\n[Leaf]\n-\u003e\n[SuperCommon]/[Leaf]\n-------------\u003e\n[SuperCommon]/[Common]/[Leaf]\n----------------------\u003e\n\nEXAMPLES\nhestiaSTRING\n   ⮱ hestiaSTRING.M64_Sanitize\nhestiaNET/hestiaHTTP\n   ⮱ hestiaHTTP.Server\n   ⮱ hestiaHTTP.Client\nhestiaNET/hestiaHTTP/hestiaPWA\n   ⮱ hestiaPWA.ToAppJS\n   ⮱ hestiaPWA.ToAppManifest\n","图像":{},"大纲":"在ZORALab赫斯提亚里，××永远让顾客导入最后端的代码包（统称‘叶子包’）××。开发者永\n远都要把叶子包给写得自给自足方式。至于前一层的代码包（统称‘树枝包’或‘父母包’），\n**它们的责任是为他们所有的叶子包供应共同数据和功能**。以下是导入方向的模式：\n","层度":3,"标题":"导入方向"},{"URL":[],"代码":"「·模范·」\n软件包   = (x_)[origin][OUTPUT](_[VARIANT](_[SKU]))\n固定值   = (X/x_)(priv_)[PURPOSE]_[NAME](_[VARIANT](_[SKU]))\n功能     = (X/x_)[[S/s]/[M/m]][CPU_BITS/N]_[Verb](_[VARIANT](_[SKU]))\n格式     = (X/x_)[[S/s]/[M/m]][CPU_BITS/N]_[Verb](_[VARIANT](_[SKU]))\n\n\n「·图例指示器·」\n()     = 随和\n[]     = 必修的变化值\n/      = 或者\nlower  = 小型字母\nUPPER  = 大型字母\nX_, x_ = 实验类\n\n\n\n\n---- 例子 ----\n「·软件包·」\nhestiaSTRING                   (hugo, go, nim)\nx_hestiaSTRING                 (hugo, go, nim)\nhestiaGUI/zoralabCORE          (hugo, go, nim)\nhestiaGUI/x_zoralabCORE        (hugo, go, nim)\nx_hestiaGUI/x_zoralabCORE      (hugo, go, nim)\n\n\n「·固定值·」\nhestiaNET.TLS_1_3              (go-pub, nim-pub*)\nhestiaNET.X_TLS_1_3            (go-pub, nim-pub*)\nhestiaSYS.SYSTEM_NAME          (go-pub, nim-pub*)\nhestiaNET.priv_TLS_1_3         (go-priv, nim-priv)\nhestiaNET.priv_TLS_1_3         (go-priv, nim-priv)\nhestiaSYS.priv_SYSTEM_NAME     (go-priv, nim-priv)\n\n\n「·功能·」\nhestiaSTRING/Sanitize          (hugo-pub)\nhestiaSTRING.M64_Sanitize      (go-pub, nim-pub*)\nhestiaSTRING.S8_Sanitize       (go-pub, nim-pub*)\nhestiaSTRING.m64_Sanitize_V2   (go-priv, nim-priv)\nhestiaSTRING.s8_Sanitize_V2    (go-priv, nim-priv)\nhestiaSTRING.X_S8_Sanitize_V3  (go-pub, nim-pub*)\nhestiaSTRING.x_S8_Sanitize_V3  (go-priv, nim-priv)\nhestiaTESTING.SN_Format        (go-pub, nim-pub*)\nhestiaTESTING.MN_Format        (go-pub, nim-pub*)\n\n\n「·格式·」\nobj.M64_Sanitize               (go-pub, nim-pub*)\nobj.S8_Sanitize                (go-pub, nim-pub*)\nobj.m64_Sanitize_V2            (go-priv, nim-priv)\nobj.s8_Sanitize_V2             (go-priv, nim-priv)\nobj.X_S8_Sanitize_V3           (go-pub, nim-pub*)\nobj.x_S8_Sanitize_V3           (go-priv, nim-priv)\n","图像":{},"大纲":"为了促进以上的规则和为了供应良好的互操作性体验和避免与标准库冲突，\nZORALab赫斯提亚为它所有支持的科技而雇用自己的命名模范。我们还是运用Go的标题案例\n为出口指示器和Nim在它的语言需要的尾段的星号。ZORALab赫斯提亚的命名模式如下：\n","层度":3,"标题":"命名模范"},{"URL":[],"代码":"","图像":{},"大纲":"通过窜字符串来表达错误在记忆空间稀少的环境里是蛮昂贵的。如此以来，我们就只能运用\n传统的错误（hestiaERROR代码包-2个字节位）代码来表啦。还有：千万不可恐慌。所有的\n功能和格式都必须越有确定性越好。基本上，越少抽象化越好。\n","层度":3,"标题":"错误代码和不可恐慌"},{"URL":[],"代码":"","图像":{},"大纲":"Generics只能在1中元编程的用法条件下可使用。头痛的问题是在不同的中央处理器的位大小\n单位算法里，各有不同的运行方式。Generics是不可能做到的。这种情况下，唯有Macro才能\n有这个能力。所以呢，如果支持的语言有Macro功能，那就运用吧。千万不可使用Generics。\n","层度":3,"标题":"使用Macro和避免使用Generics"},{"URL":[],"代码":"Add\nAppend\nBegin\nCopy\nDelete\nDivide\nEnd\nIndex(类型)\nInsert(类型)\nJoin\nLength\nMinus\nModulus\nMultiply\nNext\nParse[对象]\nPop\nPrepend\nPrevious\nReplace(类型)\nReserve\nSanitize\nScan\nSearch\nSort(类型)\nSplit(类型)\nString\nTo[对象]\nValidate(类型)\nZero\n\n\n「·图例指示器·」\n()     = 随和\n[]     = 必修的变化值\n","图像":{},"大纲":"既然代码包是用输出出产类型而被立名，那我们是先以功能方式为先，格式为有需要鸭子打\n字需求和相关处理需求而定。重点是要不管任何方式要把它们全部给好好记录啦。所有目前\n运用的动词如下:\n","层度":3,"标题":"功能vs格式"},{"URL":[],"代码":"","图像":{},"大纲":"所有的代码包必须支持WASM和无条件之下可以运用。我们绝对不可让顾客在用JavaScript去\n做任何事包括界面渲染工作（这就是代码包的首先责任啊）。\n","层度":3,"标题":"WASM能力"}]}