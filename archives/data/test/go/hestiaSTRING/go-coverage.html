
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>hestiaSTRING: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">hestia/hestiaSTRING/Clone.go (0.0%)</option>
				
				<option value="file1">hestia/hestiaSTRING/Contains.go (0.0%)</option>
				
				<option value="file2">hestia/hestiaSTRING/Formatting.go (53.8%)</option>
				
				<option value="file3">hestia/hestiaSTRING/Join.go (0.0%)</option>
				
				<option value="file4">hestia/hestiaSTRING/Print.go (0.0%)</option>
				
				<option value="file5">hestia/hestiaSTRING/Replace.go (0.0%)</option>
				
				<option value="file6">hestia/hestiaSTRING/Split.go (0.0%)</option>
				
				<option value="file7">hestia/hestiaSTRING/Trim.go (0.0%)</option>
				
				<option value="file8">hestia/hestiaSTRING/Validation.go (0.0%)</option>
				
				<option value="file9">hestia/hestiaSTRING/s-formatting-integer.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright 2022 "Holloway" Chew, Kean Ho &lt;kean.ho.chew@zoralab.com&gt;
// Copyright 2022 ZORALab Enterprise &lt;tech@zoralab.com&gt;
//
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//                  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

package hestiaSTRING

import (
        "strings"
)

func Clone(source string) string <span class="cov0" title="0">{
        return strings.Clone(source)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright 2022 "Holloway" Chew, Kean Ho &lt;kean.ho.chew@zoralab.com&gt;
// Copyright 2022 ZORALab Enterprise &lt;tech@zoralab.com&gt;
//
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//                  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

package hestiaSTRING

import (
        "strings"
)

func Contains(source, subString string) bool <span class="cov0" title="0">{
        return IndexLeft(source, subString) &gt;= 0
}</span>

func ContainsAny(source, charset string) bool <span class="cov0" title="0">{
        return IndexAny(source, charset) &gt;= 0
}</span>

func IndexLeft(source, charset string) int64 <span class="cov0" title="0">{
        return int64(strings.Index(source, charset))
}</span>

func IndexRight(source, charset string) int64 <span class="cov0" title="0">{
        return int64(strings.LastIndex(source, charset))
}</span>

func IndexAny(source, charset string) int64 <span class="cov0" title="0">{
        return int64(strings.IndexAny(source, charset))
}</span>

func HasPrefix(source, prefix string) bool <span class="cov0" title="0">{
        return strings.HasPrefix(source, prefix)
}</span>

func HasSuffix(source, suffix string) bool <span class="cov0" title="0">{
        return strings.HasSuffix(source, suffix)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright 2022 "Holloway" Chew, Kean Ho &lt;kean.ho.chew@zoralab.com&gt;
// Copyright 2022 ZORALab Enterprise &lt;tech@zoralab.com&gt;
// Copyright 2009 The Go Authors &lt;https://cs.opensource.google/go/go&gt;
//
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//                  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

package hestiaSTRING

import (
        "hestia/hestiaERROR"
        "hestia/hestiaINTERNAL/hestiaFMT"
        "strings"
        "unicode"
)

type CharsMap uint8

const (
        CHARSMAP_DEFAULT CharsMap = iota
        CHARSMAP_TURKISH
        CHARSMAP_AZERI
)

const (
        LETTERCASE_LOWER = hestiaFMT.LETTERCASE_LOWER
        LETTERCASE_UPPER = hestiaFMT.LETTERCASE_UPPER
)

const (
        DIGITS = "0123456789abcdefghijklmnopqrstuvwxyz"
)

func ToUppercase(source string, charmap CharsMap) string <span class="cov0" title="0">{
        switch charmap </span>{
        case CHARSMAP_TURKISH:<span class="cov0" title="0">
                return strings.ToUpperSpecial(unicode.TurkishCase, source)</span>
        case CHARSMAP_AZERI:<span class="cov0" title="0">
                return strings.ToUpperSpecial(unicode.TurkishCase, source)</span>
        default:<span class="cov0" title="0">
                return strings.ToUpper(source)</span>
        }
}

func ToLowercase(source string, charmap CharsMap) string <span class="cov0" title="0">{
        switch charmap </span>{
        case CHARSMAP_TURKISH:<span class="cov0" title="0">
                return strings.ToLowerSpecial(unicode.TurkishCase, source)</span>
        case CHARSMAP_AZERI:<span class="cov0" title="0">
                return strings.ToLowerSpecial(unicode.TurkishCase, source)</span>
        default:<span class="cov0" title="0">
                return strings.ToLower(source)</span>
        }
}

func ToTitlecase(source string, charmap CharsMap) string <span class="cov0" title="0">{
        switch charmap </span>{
        case CHARSMAP_TURKISH:<span class="cov0" title="0">
                return strings.ToTitleSpecial(unicode.TurkishCase, source)</span>
        case CHARSMAP_AZERI:<span class="cov0" title="0">
                return strings.ToTitleSpecial(unicode.TurkishCase, source)</span>
        default:<span class="cov0" title="0">
                return strings.ToTitle(source)</span>
        }
}

func S8_FormatUINT8(input uint8, base uint8,
        lettercase hestiaFMT.Lettercase) (out string, err hestiaERROR.Error) <span class="cov10" title="23">{
        if base &lt; 2 || base &gt; 36 </span><span class="cov4" title="3">{
                return "", hestiaERROR.DATA_INVALID
        }</span>

        <span class="cov9" title="20">if input == 0 </span><span class="cov4" title="3">{
                return "0", hestiaERROR.OK
        }</span>

        <span class="cov9" title="17">switch lettercase </span>{
        case LETTERCASE_UPPER, LETTERCASE_LOWER:<span class="cov8" title="16"></span>
        default:<span class="cov1" title="1">
                lettercase = LETTERCASE_LOWER</span>
        }

        <span class="cov9" title="17">return string(hestiaFMT.FormatUINT8(input, base, lettercase)), hestiaERROR.OK</span>
}

func S16_FormatUINT16(input uint16, base uint16,
        lettercase hestiaFMT.Lettercase) (out string, err hestiaERROR.Error) <span class="cov10" title="23">{
        if base &lt; 2 || base &gt; 36 </span><span class="cov4" title="3">{
                return "", hestiaERROR.DATA_INVALID
        }</span>

        <span class="cov9" title="20">if input == 0 </span><span class="cov4" title="3">{
                return "0", hestiaERROR.OK
        }</span>

        <span class="cov9" title="17">switch lettercase </span>{
        case LETTERCASE_UPPER, LETTERCASE_LOWER:<span class="cov8" title="16"></span>
        default:<span class="cov1" title="1">
                lettercase = LETTERCASE_LOWER</span>
        }

        <span class="cov9" title="17">return string(hestiaFMT.FormatUINT16(input, base, lettercase)), hestiaERROR.OK</span>
}

func S32_FormatUINT32(input uint32, base uint32,
        lettercase hestiaFMT.Lettercase) (out string, err hestiaERROR.Error) <span class="cov10" title="23">{
        if base &lt; 2 || base &gt; 36 </span><span class="cov4" title="3">{
                return "", hestiaERROR.DATA_INVALID
        }</span>

        <span class="cov9" title="20">if input == 0 </span><span class="cov4" title="3">{
                return "0", hestiaERROR.OK
        }</span>

        <span class="cov9" title="17">switch lettercase </span>{
        case LETTERCASE_UPPER, LETTERCASE_LOWER:<span class="cov8" title="16"></span>
        default:<span class="cov1" title="1">
                lettercase = LETTERCASE_LOWER</span>
        }

        <span class="cov9" title="17">return string(hestiaFMT.FormatUINT32(input, base, lettercase)), hestiaERROR.OK</span>
}

func S64_FormatUINT64(input uint64, base uint64,
        lettercase hestiaFMT.Lettercase) (out string, err hestiaERROR.Error) <span class="cov10" title="23">{
        if base &lt; 2 || base &gt; 36 </span><span class="cov4" title="3">{
                return "", hestiaERROR.DATA_INVALID
        }</span>

        <span class="cov9" title="20">if input == 0 </span><span class="cov4" title="3">{
                return "0", hestiaERROR.OK
        }</span>

        <span class="cov9" title="17">switch lettercase </span>{
        case LETTERCASE_UPPER, LETTERCASE_LOWER:<span class="cov8" title="16"></span>
        default:<span class="cov1" title="1">
                lettercase = LETTERCASE_LOWER</span>
        }

        <span class="cov9" title="17">return string(hestiaFMT.FormatUINT64(input, base, lettercase)), hestiaERROR.OK</span>
}

func S_ParseUINT(input string, base, size uint16) (out uint64, err hestiaERROR.Error) <span class="cov0" title="0">{
        return s_ParseUINT(input, uint64(base), size)
}</span>

func S_FormatINT(input int64, base uint) string <span class="cov0" title="0">{
        return s_FormatBits(uint64(input), base, input &lt; 0)
}</span>

func S_ParseINT(input string, base, size uint16) (out int64, err hestiaERROR.Error) <span class="cov0" title="0">{
        return s_ParseINT(input, uint64(base), size)
}</span>

func S_Itoa(input int64) string <span class="cov0" title="0">{
        return s_FormatBits(uint64(input), 10, input &lt; 0)
}</span>

func S_Atoi(input string, size uint16) (out int64, err hestiaERROR.Error) <span class="cov0" title="0">{
        return s_ParseINT(input, 10, size)
}</span>

func FormatBOOL(input bool) string <span class="cov0" title="0">{
        if input </span><span class="cov0" title="0">{
                return "true"
        }</span>

        <span class="cov0" title="0">return "false"</span>
}

func ParseBOOL(input string) (bool, hestiaERROR.Error) <span class="cov0" title="0">{
        switch ToUppercase(input, CHARSMAP_DEFAULT) </span>{
        case "1", "T", "TRUE":<span class="cov0" title="0">
                return true, hestiaERROR.OK</span>
        case "0", "F", "FALSE":<span class="cov0" title="0">
                return false, hestiaERROR.OK</span>
        default:<span class="cov0" title="0">
                return false, hestiaERROR.INVALID_ARGUMENT</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright 2022 "Holloway" Chew, Kean Ho &lt;kean.ho.chew@zoralab.com&gt;
// Copyright 2022 ZORALab Enterprise &lt;tech@zoralab.com&gt;
//
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//                  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

package hestiaSTRING

import (
        "strings"
)

func Join(list []string, delimit, last string) string <span class="cov0" title="0">{
        var s string

        if last == "" || delimit == last </span><span class="cov0" title="0">{
                return strings.Join(list, delimit)
        }</span>

        <span class="cov0" title="0">s = strings.Join(list[:len(list)-1], delimit)
        list = []string{s, list[len(list)-1]}
        return strings.Join(list, last)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright 2022 "Holloway" Chew, Kean Ho &lt;kean.ho.chew@zoralab.com&gt;
// Copyright 2022 ZORALab Enterprise &lt;tech@zoralab.com&gt;
//
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//                  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

package hestiaSTRING

import (
        "fmt"
)

func Printf(format string, args ...any) string <span class="cov0" title="0">{
        return fmt.Sprintf(format, args...)
}</span>

func Println(args ...any) string <span class="cov0" title="0">{
        return fmt.Sprintln(args...)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright 2022 "Holloway" Chew, Kean Ho &lt;kean.ho.chew@zoralab.com&gt;
// Copyright 2022 ZORALab Enterprise &lt;tech@zoralab.com&gt;
//
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//                  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

package hestiaSTRING

import (
        "strings"
)

func Replace(source, target, payload string, quantity int) string <span class="cov0" title="0">{
        return strings.Replace(source, target, payload, quantity)
}</span>

func ReplaceAll(source, target, payload string) string <span class="cov0" title="0">{
        return strings.ReplaceAll(source, target, payload)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright 2022 "Holloway" Chew, Kean Ho &lt;kean.ho.chew@zoralab.com&gt;
// Copyright 2022 ZORALab Enterprise &lt;tech@zoralab.com&gt;
//
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//                  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

package hestiaSTRING

import (
        "strings"
)

const (
        SPLIT_ALL int = -1
)

func Cut(source, delimit string) (before, after string, found bool) <span class="cov0" title="0">{
        return strings.Cut(source, delimit)
}</span>

func Split(source, delimit string, count int) []string <span class="cov0" title="0">{
        return strings.SplitN(source, delimit, count)
}</span>

func SplitAfter(source, delimit string, count int) []string <span class="cov0" title="0">{
        return strings.SplitAfterN(source, delimit, count)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright 2022 "Holloway" Chew, Kean Ho &lt;kean.ho.chew@zoralab.com&gt;
// Copyright 2022 ZORALab Enterprise &lt;tech@zoralab.com&gt;
//
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//                  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

// Test code: https://go.dev/play/p/JKiXhIZX9Kk

package hestiaSTRING

import (
        "strings"
        "unicode"
)

func Trim(source string, cutset string) string <span class="cov0" title="0">{
        return strings.Trim(source, cutset)
}</span>

func TrimLeft(source string, cutset string) string <span class="cov0" title="0">{
        return strings.TrimLeft(source, cutset)
}</span>

func TrimRight(source string, cutset string) string <span class="cov0" title="0">{
        return strings.TrimRight(source, cutset)
}</span>

func TrimWhitespace(source string) string <span class="cov0" title="0">{
        var leftIndex, rightIndex uint64
        var next bool

        if source == "" </span><span class="cov0" title="0">{
                return source
        }</span>

        <span class="cov0" title="0">for i, char := range source </span><span class="cov0" title="0">{
                if !unicode.IsSpace(char) </span><span class="cov0" title="0">{
                        if leftIndex == 0 </span><span class="cov0" title="0">{
                                leftIndex = uint64(i)
                        }</span>

                        <span class="cov0" title="0">rightIndex = uint64(i)
                        next = true
                        continue</span>
                }

                <span class="cov0" title="0">if next </span><span class="cov0" title="0">{
                        rightIndex = uint64(i)
                        next = false
                }</span>
        }

        <span class="cov0" title="0">if next </span><span class="cov0" title="0">{
                rightIndex = uint64(len(source))
        }</span>

        <span class="cov0" title="0">if leftIndex == 0 &amp;&amp; rightIndex == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return source[leftIndex:rightIndex]</span>
}

func TrimWhitespaceLeft(source string) string <span class="cov0" title="0">{
        var index uint64
        var stillWhitespace bool

        if source == "" </span><span class="cov0" title="0">{
                return source
        }</span>

        <span class="cov0" title="0">stillWhitespace = true
        for i, char := range source </span><span class="cov0" title="0">{
                if !unicode.IsSpace(char) </span><span class="cov0" title="0">{
                        index = uint64(i)
                        stillWhitespace = false
                        break</span>
                }
        }

        <span class="cov0" title="0">if stillWhitespace </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return source[index:]</span>
}

func TrimWhitespaceRight(source string) string <span class="cov0" title="0">{
        var index uint64
        var next bool

        if source == "" </span><span class="cov0" title="0">{
                return source
        }</span>

        <span class="cov0" title="0">for i, char := range source </span><span class="cov0" title="0">{
                if !unicode.IsSpace(char) </span><span class="cov0" title="0">{
                        index = uint64(i)
                        next = true
                        continue</span>
                }

                <span class="cov0" title="0">if next </span><span class="cov0" title="0">{
                        index = uint64(i)
                        next = false
                }</span>
        }

        <span class="cov0" title="0">if next </span><span class="cov0" title="0">{
                index = uint64(len(source))
        }</span>

        <span class="cov0" title="0">if index == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return source[:index]</span>
}

func TrimPrefix(source, prefix string) string <span class="cov0" title="0">{
        return strings.TrimPrefix(source, prefix)
}</span>

func TrimSuffix(source, suffix string) string <span class="cov0" title="0">{
        return strings.TrimSuffix(source, suffix)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright 2022 "Holloway" Chew, Kean Ho &lt;kean.ho.chew@zoralab.com&gt;
// Copyright 2022 ZORALab Enterprise &lt;tech@zoralab.com&gt;
//
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//                  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

package hestiaSTRING

func IsString(input any) (ok bool) <span class="cov0" title="0">{
        if _, ok = input.(string); ok </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if _, ok = input.(*string); ok </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright 2022 "Holloway" Chew, Kean Ho &lt;kean.ho.chew@zoralab.com&gt;
// Copyright 2022 ZORALab Enterprise &lt;tech@zoralab.com&gt;
// Copyright 2009 The Go Authors &lt;https://cs.opensource.google/go/go&gt;
//
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//                  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

package hestiaSTRING

import (
        "hestia/hestiaERROR"
        "hestia/hestiaNUMBER/hestiaBITS"
)

const (
        priv_BASE_GUESS    uint64 = 100
        priv_BASE_GUESS_2         = priv_BASE_GUESS + 2
        priv_BASE_GUESS_8         = priv_BASE_GUESS + 8
        priv_BASE_GUESS_10        = priv_BASE_GUESS + 10
)

func s_FormatBits(input uint64, base uint, isNegative bool) (out string) <span class="cov0" title="0">{
        var i int
        var x, base_uint64 uint64
        var buffer [64 + 1]byte // +1 for base-2 signed value

        if base &lt; 2 || base &gt; uint(len(DIGITS)) </span><span class="cov0" title="0">{
                panic("base conversion must be 2 ≥ x ≥ 36")</span>
        }

        <span class="cov0" title="0">i = len(buffer)

        if isNegative </span><span class="cov0" title="0">{
                // modulus back to positive number for division
                input = -input
        }</span>

        <span class="cov0" title="0">base_uint64 = uint64(base)

        switch </span>{
        case base&amp;(base-1) == 0:<span class="cov0" title="0"> // power of 2
                // x is shift
                x = hestiaBITS.S64_TrailingZeros(uint64(base)) &amp; 7
                for input &gt;= base_uint64 </span><span class="cov0" title="0">{
                        i--
                        buffer[i] = DIGITS[uint(input)&amp;(base-1)]
                        input &gt;&gt;= x
                }</span>

                <span class="cov0" title="0">i--
                buffer[i] = DIGITS[uint(input)]</span>
        default:<span class="cov0" title="0">
                // x is quotient
                for input &gt;= base_uint64 </span><span class="cov0" title="0">{
                        i--

                        x = input / base_uint64
                        buffer[i] = DIGITS[uint(input-x*base_uint64)]
                        input = x
                }</span>

                <span class="cov0" title="0">i--
                buffer[i] = DIGITS[uint(input)]</span>
        }

        <span class="cov0" title="0">if isNegative </span><span class="cov0" title="0">{
                i--
                buffer[i] = '-'
        }</span>

        <span class="cov0" title="0">return string(buffer[i:])</span>
}

func s_ParseINT(input string, base uint64, size uint16) (value int64, err hestiaERROR.Error) <span class="cov0" title="0">{
        var isNegative bool
        var number uint64

        number, isNegative, err = _parseInteger(input, base, true)
        if err != hestiaERROR.OK </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">err = hestiaBITS.S64_Resize(&amp;number, size, true)
        if err != hestiaERROR.OK </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">value = int64(number)

        if isNegative </span><span class="cov0" title="0">{
                value *= -1
        }</span>

        <span class="cov0" title="0">return 0, hestiaERROR.OK</span>
}

func s_ParseUINT(input string, base uint64, size uint16) (value uint64, err hestiaERROR.Error) <span class="cov0" title="0">{
        value, _, err = _parseInteger(input, base, false)
        if err != hestiaERROR.OK </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">err = hestiaBITS.S64_Resize(&amp;value, size, false)
        if err != hestiaERROR.OK </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return value, hestiaERROR.OK</span>
}

func _parseInteger(input string,
        base uint64, withSign bool) (value uint64, isNegative bool, err hestiaERROR.Error) <span class="cov0" title="0">{
        var buffer []uint8
        var underscored bool
        var sign int8

        // PHASE 0: ensure base is within supported values
        switch base </span>{
        case 0, 2, 8, 10, 16:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                return 0, false, hestiaERROR.UNSUPPORTED</span>
        }

        // PHASE 1: scan the string
        <span class="cov0" title="0">buffer = []uint8{}
        for i, char := range input </span><span class="cov0" title="0">{
                if char == '_' &amp;&amp; i == 0 </span><span class="cov0" title="0">{
                        // fail leading underscore (_42 = identifier)
                        return 0, false, hestiaERROR.INVALID_ARGUMENT
                }</span>

                <span class="cov0" title="0">__scanNumberString(char, &amp;base, &amp;sign, &amp;buffer, &amp;underscored, &amp;err)
                if err != hestiaERROR.OK </span><span class="cov0" title="0">{
                        return 0, false, err
                }</span>

                <span class="cov0" title="0">if !withSign &amp;&amp; sign &lt; 0 </span><span class="cov0" title="0">{
                        // fail early if the parsing is for unsigned integer but
                        // given number is already detected as negative.
                        return 0, false, hestiaERROR.INVALID_ARGUMENT
                }</span>
        }

        // 1.1: fail tailing underscore (42_ = invalid)
        <span class="cov0" title="0">if underscored </span><span class="cov0" title="0">{
                return 0, false, hestiaERROR.INVALID_ARGUMENT
        }</span>

        // 1.2: realign guessed base number
        <span class="cov0" title="0">switch base </span>{
        case 2, priv_BASE_GUESS_2:<span class="cov0" title="0">
                base = 2</span>
        case 8, priv_BASE_GUESS_8:<span class="cov0" title="0">
                base = 8</span>
        case 10, priv_BASE_GUESS_10:<span class="cov0" title="0">
                base = 10</span>
        case 16:<span class="cov0" title="0">
                base = 16</span>
        default:<span class="cov0" title="0">
                return 0, false, hestiaERROR.UNSUPPORTED</span>
        }

        // PHASE 2: calculate final value
        <span class="cov0" title="0">__calculateParsedNumber(&amp;value, &amp;buffer, &amp;base)

        // PHASE 3: set number sign
        isNegative = false
        if sign &lt; 0 </span><span class="cov0" title="0">{
                isNegative = true
        }</span>

        <span class="cov0" title="0">return value, isNegative, err</span>
}

func __calculateParsedNumber(value *uint64, buffer *[]uint8, base *uint64) <span class="cov0" title="0">{
        var i, position uint64

        *value = 0
        i = uint64(len(*buffer)) - 1

        position = 1
        for ; i != 0; i-- </span><span class="cov0" title="0">{
                *value = uint64((*buffer)[i]) * position
                position *= *base
        }</span>
}

func __scanNumberString(char rune, base *uint64,
        sign *int8, buffer *[]uint8, underscored *bool, err *hestiaERROR.Error) <span class="cov0" title="0">{
        switch char </span>{
        case '0':<span class="cov0" title="0">
                ___parseNumber0(&amp;char, base, buffer, err)
                *underscored = false</span>
        case '1':<span class="cov0" title="0">
                ___parseNumber1(&amp;char, base, buffer, err)
                *underscored = false</span>
        case '2', '3', '4', '5', '6', '7':<span class="cov0" title="0">
                ___parseNumberOctet(&amp;char, base, buffer, err)
                *underscored = false</span>
        case '8', '9':<span class="cov0" title="0">
                ___parseNumberDecimal(&amp;char, base, buffer, err)
                *underscored = false</span>
        case 'a', 'A', 'c', 'C', 'd', 'D', 'e', 'E', 'f', 'F':<span class="cov0" title="0">
                ___parseNumberHex(&amp;char, base, buffer, err)
                *underscored = false</span>
        case 'b', 'B':<span class="cov0" title="0">
                ___parseNumberHexB(&amp;char, base, buffer, underscored, err)
                *underscored = false</span>
        case 'o', 'O':<span class="cov0" title="0">
                if *base == priv_BASE_GUESS &amp;&amp; !*underscored </span><span class="cov0" title="0">{
                        // confirmed as octet: '0o1234567' or '0O1234567'
                        *base = 8
                        return
                }</span>

                // fail unsuccessive digits ('0_o1234567')
                <span class="cov0" title="0">*err = hestiaERROR.INVALID_ARGUMENT</span>
        case 'x', 'X':<span class="cov0" title="0">
                if *base == priv_BASE_GUESS &amp;&amp; !*underscored </span><span class="cov0" title="0">{
                        // confirmed as hex: '0x1234567' or '0X1234567'
                        *base = 16
                        return
                }</span>

                // fail unsuccessive digits ('0_xBadFace')
                <span class="cov0" title="0">*err = hestiaERROR.INVALID_ARGUMENT</span>
        case '+':<span class="cov0" title="0">
                if *sign == 0 </span><span class="cov0" title="0">{
                        // confirm sign (e.g. '+0b1010111' OR '+12345')
                        *sign = 1
                        *underscored = false
                        return
                }</span>

                // fail sign in the middle of a digit ('...123+123...')
                <span class="cov0" title="0">*err = hestiaERROR.INVALID_ARGUMENT</span>
        case '-':<span class="cov0" title="0">
                if *sign == 0 </span><span class="cov0" title="0">{
                        // confirm sign (e.g. '-0b1010111' OR '-12345')
                        *sign = -1
                        *underscored = false
                        return
                }</span>

                // fail sign in the middle of a digit ('...123-123...')
                <span class="cov0" title="0">*err = hestiaERROR.INVALID_ARGUMENT</span>
        case '_':<span class="cov0" title="0">
                if !*underscored </span><span class="cov0" title="0">{
                        *underscored = true
                        return
                }</span>

                // fail repeating underscore (4__2 = invalid)
                <span class="cov0" title="0">*err = hestiaERROR.INVALID_ARGUMENT</span>
        }
}

func ___parseNumberHexB(char *rune, base *uint64,
        buffer *[]uint8, underscored *bool, err *hestiaERROR.Error) <span class="cov0" title="0">{
        switch *base </span>{
        case 0, priv_BASE_GUESS_2, priv_BASE_GUESS_8, priv_BASE_GUESS_10:<span class="cov0" title="0">
                // User requested base number guessing and supplied a hex digit.
                // So, we promote the guessable base to 16.
                //
                // We can confirm this number as max base since Go literal
                // prohibits any other bigger integer literal input. See:
                //   1. https://go.dev/ref/spec#Integer_literals
                //   2. https://go.dev/ref/spec#Letters_and_digits
                *base = 16
                ____saveToBuffer(char, buffer)
                return</span>
        case 16:<span class="cov0" title="0">
                ____saveToBuffer(char, buffer)
                return</span>
        case priv_BASE_GUESS:<span class="cov0" title="0">
                if !*underscored </span><span class="cov0" title="0">{
                        // confirmed as bin: '0b1011011' or '0B101011101'
                        *base = 2
                        return
                }</span>

                // fail unsuccessive digits ('0_b1011101' = invalid)
        }

        <span class="cov0" title="0">*err = hestiaERROR.INVALID_ARGUMENT</span>
}

func ___parseNumberHex(char *rune, base *uint64, buffer *[]uint8, err *hestiaERROR.Error) <span class="cov0" title="0">{
        switch *base </span>{
        case 0, priv_BASE_GUESS_2, priv_BASE_GUESS_8, priv_BASE_GUESS_10:<span class="cov0" title="0">
                // User requested base number guessing and supplied a hex digit.
                // So, we promote the guessable base to 16.
                //
                // We can confirm this number as max base since Go literal
                // prohibits any other bigger integer literal input. See:
                //   1. https://go.dev/ref/spec#Integer_literals
                //   2. https://go.dev/ref/spec#Letters_and_digits
                *base = 16
                ____saveToBuffer(char, buffer)
                return</span>
        case 16:<span class="cov0" title="0">
                ____saveToBuffer(char, buffer)
                return</span>
        }

        <span class="cov0" title="0">*err = hestiaERROR.INVALID_ARGUMENT</span>
}

func ___parseNumberDecimal(char *rune, base *uint64, buffer *[]uint8, err *hestiaERROR.Error) <span class="cov0" title="0">{
        *err = hestiaERROR.INVALID_ARGUMENT
        switch *base </span>{
        case 0, priv_BASE_GUESS, priv_BASE_GUESS_2, priv_BASE_GUESS_8:<span class="cov0" title="0">
                // User requested base number guessing and supplied a decimal
                // digit. So, we promote the guessable base to 10.
                *base = priv_BASE_GUESS_10
                ____saveToBuffer(char, buffer)
                return</span>
        case 10, priv_BASE_GUESS_10:<span class="cov0" title="0">
                fallthrough</span>
        case 16:<span class="cov0" title="0">
                ____saveToBuffer(char, buffer)
                return</span>
        }

        <span class="cov0" title="0">*err = hestiaERROR.INVALID_ARGUMENT</span>
}

func ___parseNumberOctet(char *rune, base *uint64, buffer *[]uint8, err *hestiaERROR.Error) <span class="cov0" title="0">{
        switch *base </span>{
        case 0, priv_BASE_GUESS, priv_BASE_GUESS_2:<span class="cov0" title="0">
                // User requested base number guessing and supplied an octet
                // digit. So, we promote the guessable base to 8.
                *base = priv_BASE_GUESS_8
                ____saveToBuffer(char, buffer)
                return</span>
        case 8, priv_BASE_GUESS_8:<span class="cov0" title="0">
                fallthrough</span>
        case 10, priv_BASE_GUESS_10:<span class="cov0" title="0">
                fallthrough</span>
        case 16:<span class="cov0" title="0">
                ____saveToBuffer(char, buffer)
                return</span>
        }

        <span class="cov0" title="0">*err = hestiaERROR.INVALID_ARGUMENT</span>
}

func ___parseNumber1(char *rune, base *uint64, buffer *[]uint8, err *hestiaERROR.Error) <span class="cov0" title="0">{
        switch *base </span>{
        case 0, priv_BASE_GUESS:<span class="cov0" title="0">
                // User requested base number guessing and supplied a digit '1'
                // which can be a value of various base numbers.  So, we take
                // the smallest guessable base '2' and promote it as as we go.
                *base = priv_BASE_GUESS_2
                ____saveToBuffer(char, buffer)
                return</span>
        case 2, priv_BASE_GUESS_2:<span class="cov0" title="0">
                fallthrough</span>
        case 8, priv_BASE_GUESS_8:<span class="cov0" title="0">
                fallthrough</span>
        case 10, priv_BASE_GUESS_10:<span class="cov0" title="0">
                fallthrough</span>
        case 16:<span class="cov0" title="0">
                ____saveToBuffer(char, buffer)
                return</span>
        }

        <span class="cov0" title="0">*err = hestiaERROR.INVALID_ARGUMENT</span>
}

func ___parseNumber0(char *rune, base *uint64, buffer *[]uint8, err *hestiaERROR.Error) <span class="cov0" title="0">{
        switch *base </span>{
        case 0:<span class="cov0" title="0">
                // User requested base number guessing and supplied '0' digit
                // which can be integer literal OR a value of various base
                // numbers. We have to guess it as we go along.
                *base = priv_BASE_GUESS
                return</span>
        case priv_BASE_GUESS:<span class="cov0" title="0">
                // Subsequent digit is still '0'. Do nothing.
                return</span>
        case 2, priv_BASE_GUESS_2:<span class="cov0" title="0">
                fallthrough</span>
        case 8, priv_BASE_GUESS_8:<span class="cov0" title="0">
                fallthrough</span>
        case 10, priv_BASE_GUESS_10:<span class="cov0" title="0">
                fallthrough</span>
        case 16:<span class="cov0" title="0">
                ____saveToBuffer(char, buffer)
                return</span>
        }

        <span class="cov0" title="0">*err = hestiaERROR.INVALID_ARGUMENT</span>
}

func ____saveToBuffer(char *rune, buffer *[]uint8) <span class="cov0" title="0">{
        switch *char </span>{
        case '0':<span class="cov0" title="0">
                *buffer = append(*buffer, 0)</span>
        case '1':<span class="cov0" title="0">
                *buffer = append(*buffer, 1)</span>
        case '2':<span class="cov0" title="0">
                *buffer = append(*buffer, 2)</span>
        case '3':<span class="cov0" title="0">
                *buffer = append(*buffer, 3)</span>
        case '4':<span class="cov0" title="0">
                *buffer = append(*buffer, 4)</span>
        case '5':<span class="cov0" title="0">
                *buffer = append(*buffer, 5)</span>
        case '6':<span class="cov0" title="0">
                *buffer = append(*buffer, 6)</span>
        case '7':<span class="cov0" title="0">
                *buffer = append(*buffer, 7)</span>
        case '8':<span class="cov0" title="0">
                *buffer = append(*buffer, 8)</span>
        case '9':<span class="cov0" title="0">
                *buffer = append(*buffer, 9)</span>
        case 'a', 'A':<span class="cov0" title="0">
                *buffer = append(*buffer, 10)</span>
        case 'b', 'B':<span class="cov0" title="0">
                *buffer = append(*buffer, 11)</span>
        case 'c', 'C':<span class="cov0" title="0">
                *buffer = append(*buffer, 12)</span>
        case 'd', 'D':<span class="cov0" title="0">
                *buffer = append(*buffer, 13)</span>
        case 'e', 'E':<span class="cov0" title="0">
                *buffer = append(*buffer, 14)</span>
        case 'f', 'F':<span class="cov0" title="0">
                *buffer = append(*buffer, 15)</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
