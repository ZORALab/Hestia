[[EN.List]]
Title = 'Decentralized Distribution'
HTML = '''
By design, ZORALab's Hestia carefully pick programming languages that do not
soley depending on its specialized distribution system alone for countering
geo-political and after-the-fact business changes nuisance threats (e.g.
implement restrictive geo-fencing or sudden steep price hike overnight without
any notices). At the most upstream source (us), all supported technologies MUST
be distributable and re-distributable securely, online and offline with just a
simple <code>.zip</code> archive format.
'''
Plain = '''
By design, ZORALab's Hestia carefully pick programming languages that do not
soley depending on its specialized distribution system alone for countering
geo-political and after-the-fact business changes nuisance threats (e.g.
implement restrictive geo-fencing or sudden steep price hike overnight without
any notices). At the most upstream source (us), all supported technologies MUST
be distributable and re-distributable securely, online and offline with just a
simple '.zip' archive format.
'''
Code = '''
'''

[[EN.List.URL]]
Value = ''
Label = ''


[[ZH-HANS.List]]
Title = '网络HTML+CSS优先'
HTML = '''
根据ZORALab赫斯提亚设计，我们是为了防止地缘政治和事后的肮脏诡计带来的无畏无聊的
麻烦而很小心地选出我们支持的代码语言。在选择中，我们是检验它们不单一靠自己的中心
化型方式分发软件包。在最高的开源（我们），所以支持的科技都可以不管上线或离线地
通过一个简单的<code>.zip</code>格式无中心化分发。
'''
Plain = '''
根据ZORALab赫斯提亚设计，我们是为了防止地缘政治和事后的肮脏诡计带来的无畏无聊的
麻烦而很小心地选出我们支持的代码语言。在选择中，我们是检验它们不单一靠自己的中心
化型方式分发软件包。在最高的开源（我们），所以支持的科技都可以不管上线或离线地
通过一个简单的'.zip'格式无中心化分发。
'''
Code = '''
'''

[[ZH-HANS.List.URL]]
Value = ''
Label = ''




[[EN.List]]
Title = 'Stream Vs. Memory'
HTML = '''
For ZORALab's Hestia, there are 2 orientations when it comes to designing
algorithm: (1) stream-oriented [S] focuses on extremely low memory footprint
but takes more time for processing; (2) memory-oriented [M] focuses on maximum
memory usage for faster speed. The default everyone practice is usually
memory-oriented where most people would care less about how much the memory is
used in a 64-bit operating system. Microcontrollers and embedded folks however,
tend to prefer stream-oriented due to the memory size limitations. Hence, all
functions and methods **MUST** cater both stream-oriented and memory-oriented
executions, whichever comes first.
'''
Plain = '''
For ZORALab's Hestia, there are 2 orientations when it comes to designing
algorithm: (1) stream-oriented [S] focuses on extremely low memory footprint
but takes more time for processing; (2) memory-oriented [M] focuses on maximum
memory usage for faster speed. The default everyone practice is usually
memory-oriented where most people would care less about how much the memory is
used in a 64-bit operating system. Microcontrollers and embedded folks however,
tend to prefer stream-oriented due to the memory size limitations. Hence, all
functions and methods **MUST** cater both stream-oriented and memory-oriented
executions, whichever comes first.
'''
Code = '''
'''

[[EN.List.URL]]
Value = ''
Label = ''


[[ZH-HANS.List]]
Title = '流动式vs记忆式'
HTML = '''
在ZORALab赫斯提亚设计算法，基本上有2种方式：（1）流动式[S]专注于运用非常少的记忆
空间但可以用长一点的时间来完成任务。（2）记忆式[M]专注于运用多记忆空间来快速地把
任务完成。通常大多数的开发者是建设记忆式的计算法（设计时是没有顾虑到运用多少记忆
空间）。在微型控制器和嵌入式的世界里，由于记忆空间通常是实在太小了，多数人都会使
用流动式。如此，ZORALab赫斯提亚所写的功能和运作方法··一定··要双双供应记忆式和流
动式的方式以先到者为准。
'''
Plain = '''
在ZORALab赫斯提亚设计算法，基本上有2种方式：（1）流动式[S]专注于运用非常少的记忆
空间但可以用长一点的时间来完成任务。（2）记忆式[M]专注于运用多记忆空间来快速地把
任务完成。通常大多数的开发者是建设记忆式的计算法（设计时是没有顾虑到运用多少记忆
空间）。在微型控制器和嵌入式的世界里，由于记忆空间通常是实在太小了，多数人都会使
用流动式。如此，ZORALab赫斯提亚所写的功能和运作方法··一定··要双双供应记忆式和流
动式的方式以先到者为准。
'''
Code = '''
'''

[[ZH-HANS.List.URL]]
Value = ''
Label = ''




[[EN.List]]
Title = 'Monomorphize By CPU Size'
HTML = '''
One problem ZORALab's Hestia set to solve is to facilitate all functions and
methods by CPU Size (8-Bits, 16-bits, 24-bits, 32-bits, 64-bits, ...2048-bits).
Most standard libraries are heavily geared towards 64-bits CPU, making it very
difficult to port into other CPU types like 8-bits and 16-bits. Therefore, to
combat scarcity, ZORALab's Hestia manually monomorphize all processing functions
and methods giving the end users a choice rather than no-choice.
'''
Plain = '''
One problem ZORALab's Hestia set to solve is to facilitate all functions and
methods by CPU Size (8-Bits, 16-bits, 24-bits, 32-bits, 64-bits, ...2048-bits).
Most standard libraries are heavily geared towards 64-bits CPU, making it very
difficult to port into other CPU types like 8-bits and 16-bits. Therefore, to
combat scarcity, ZORALab's Hestia manually monomorphize all processing functions
and methods giving the end users a choice rather than no-choice.
'''
Code = '''
'''

[[EN.List.URL]]
Value = ''
Label = ''


[[ZH-HANS.List]]
Title = '通过中央处理器的位大小单态化'
HTML = '''
有一个问题ZORALab赫斯提亚一定要解决的是能供应各种不同的中央处理器的位大小（如：
8-Bits、16-Bits、24-Bits、32-Bits、64-Bits、...2048-Bits）功能。多数的代码库是为
64-Bits的中央处理器而写出。这把功能移植工作给其他位大小中央处理器非常困难和复杂。
为了对抗这稀缺性的问题，ZORALab赫斯提亚会手动地通过中央处理器的位大小把所有供应
的功能单态化好让顾客有个选择总好过没有选择。
'''
Plain = '''
有一个问题ZORALab赫斯提亚一定要解决的是能供应各种不同的中央处理器的位大小（如：
8-Bits、16-Bits、24-Bits、32-Bits、64-Bits、...2048-Bits）功能。多数的代码库是为
64-Bits的中央处理器而写出。这把功能移植工作给其他位大小中央处理器非常困难和复杂。
为了对抗这稀缺性的问题，ZORALab赫斯提亚会手动地通过中央处理器的位大小把所有供应
的功能单态化好让顾客有个选择总好过没有选择。
'''
Code = '''
'''

[[ZH-HANS.List.URL]]
Value = ''
Label = ''




[[EN.List]]
Title = 'Import Direction'
HTML = '''
For ZORALab's Hestia, ALWAYS LET USER TO ONLY IMPORT LEAF PACKAGES WHENEVER
AVAILABLE. Build the leaf package to the point of self-sufficient manner. As for
the parent packages, **they are there to facilitate common utilities among the
children packages**. Below is the import pattern:
'''
Plain = '''
For ZORALab's Hestia, ALWAYS LET USER TO ONLY IMPORT LEAF PACKAGES WHENEVER
AVAILABLE. Build the leaf package to the point of self-sufficient manner. As for
the parent packages, **they are there to facilitate common utilities among the
children packages**. Below is the import pattern:
'''
Code = '''
PATTERN
[Leaf]
->
[SuperCommon]/[Leaf]
------------->
[SuperCommon]/[Common]/[Leaf]
---------------------->

EXAMPLES
hestiaSTRING
   ⮱ hestiaSTRING.M64_Sanitize
hestiaNET/hestiaHTTP
   ⮱ hestiaHTTP.Server
   ⮱ hestiaHTTP.Client
hestiaNET/hestiaHTTP/hestiaPWA
   ⮱ hestiaPWA.ToAppJS
   ⮱ hestiaPWA.ToAppManifest
'''

[[EN.List.URL]]
Value = ''
Label = ''


[[ZH-HANS.List]]
Title = '导入方向'
HTML = '''
在ZORALab赫斯提亚里，××永远让顾客导入最后端的代码包（统称‘叶子包’）××。开发者永
远都要把叶子包给写得自给自足方式。至于前一层的代码包（统称‘树枝包’或‘父母包’），
××它们的责任是为他们所有的叶子包供应共同数据和功能××。以下是导入方向的模式：
'''
Plain = '''
在ZORALab赫斯提亚里，××永远让顾客导入最后端的代码包（统称‘叶子包’）××。开发者永
远都要把叶子包给写得自给自足方式。至于前一层的代码包（统称‘树枝包’或‘父母包’），
××它们的责任是为他们所有的叶子包供应共同数据和功能××。以下是导入方向的模式：
'''
Code = '''
PATTERN
[Leaf]
->
[SuperCommon]/[Leaf]
------------->
[SuperCommon]/[Common]/[Leaf]
---------------------->

EXAMPLES
hestiaSTRING
   ⮱ hestiaSTRING.M64_Sanitize
hestiaNET/hestiaHTTP
   ⮱ hestiaHTTP.Server
   ⮱ hestiaHTTP.Client
hestiaNET/hestiaHTTP/hestiaPWA
   ⮱ hestiaPWA.ToAppJS
   ⮱ hestiaPWA.ToAppManifest
'''

[[ZH-HANS.List.URL]]
Value = ''
Label = ''




[[EN.List]]
Title = 'Naming Convention'
HTML = '''
To comply with the import direction above and to avoid conflicting with the
standard libraries for facilitating a good experience of inter-operability,
ZORALab's Hestia employs its own naming convention across all supported
technologies. We are still using Go's Titlecase as export indicator
while Nim will just append its required astrisk at the end. ZORALab's Hestia
naming convention follow this pattern:
'''
Plain = '''
To comply with the import direction above and to avoid conflicting with the
standard libraries for facilitating a good experience of inter-operability,
ZORALab's Hestia employs its own naming convention across all supported
technologies. We are still using Go's Titlecase as export indicator
while Nim will just append its required astrisk at the end. ZORALab's Hestia
naming convention follow this pattern:
'''
Code = '''
「·PATTERN·」
PACKAGE   = (x_)[origin][OUTPUT](_[VARIANT](_[SKU]))
CONSTANT  = (X/x_)(priv_)[PURPOSE]_[NAME](_[VARIANT](_[SKU]))
FUNCTION  = (X/x_)[[S/s]/[M/m]][CPU_BITS/N]_[Verb](_[VARIANT](_[SKU]))
METHOD    = (X/x_)[[S/s]/[M/m]][CPU_BITS/N]_[Verb](_[VARIANT](_[SKU]))


「·LEGENDS·」
()     = Optional
[]     = Compulsory Variable Values
/      = OR
lower  = lowercase
UPPER  = UPPERCASE
X_, x_ = experimental




---- EXAMPLES ----
「·PACKAGE·」
hestiaSTRING                   (hugo, go, nim)
x_hestiaSTRING                 (hugo, go, nim)
hestiaGUI/zoralabCORE          (hugo, go, nim)
hestiaGUI/x_zoralabCORE        (hugo, go, nim)
x_hestiaGUI/x_zoralabCORE      (hugo, go, nim)


「·CONSTANT·」
hestiaNET.TLS_1_3              (go-pub, nim-pub*)
hestiaNET.X_TLS_1_3            (go-pub, nim-pub*)
hestiaSYS.SYSTEM_NAME          (go-pub, nim-pub*)
hestiaNET.priv_TLS_1_3         (go-priv, nim-priv)
hestiaNET.priv_TLS_1_3         (go-priv, nim-priv)
hestiaSYS.priv_SYSTEM_NAME     (go-priv, nim-priv)


「·FUNCTION·」
hestiaSTRING/Sanitize          (hugo-pub)
hestiaSTRING.M64_Sanitize      (go-pub, nim-pub*)
hestiaSTRING.S8_Sanitize       (go-pub, nim-pub*)
hestiaSTRING.m64_Sanitize_V2   (go-priv, nim-priv)
hestiaSTRING.s8_Sanitize_V2    (go-priv, nim-priv)
hestiaSTRING.X_S8_Sanitize_V3  (go-pub, nim-pub*)
hestiaSTRING.x_S8_Sanitize_V3  (go-priv, nim-priv)
hestiaTESTING.SN_Format        (go-pub, nim-pub*)
hestiaTESTING.MN_Format        (go-pub, nim-pub*)


「·METHOD·」
obj.M64_Sanitize               (go-pub, nim-pub*)
obj.S8_Sanitize                (go-pub, nim-pub*)
obj.m64_Sanitize_V2            (go-priv, nim-priv)
obj.s8_Sanitize_V2             (go-priv, nim-priv)
obj.X_S8_Sanitize_V3           (go-pub, nim-pub*)
obj.x_S8_Sanitize_V3           (go-priv, nim-priv)
'''

[[EN.List.URL]]
Value = ''
Label = ''


[[ZH-HANS.List]]
Title = '命名模范'
HTML = '''
为了促进以上的规则和为了供应良好的互操作性体验和避免与标准库冲突，
ZORALab赫斯提亚为它所有支持的科技而雇用自己的命名模范。我们还是运用Go的标题案例
为出口指示器和Nim在它的语言需要的尾段的星号。ZORALab赫斯提亚的命名模式如下：
'''
Plain = '''
为了促进以上的规则和为了供应良好的互操作性体验和避免与标准库冲突，
ZORALab赫斯提亚为它所有支持的科技而雇用自己的命名模范。我们还是运用Go的标题案例
为出口指示器和Nim在它的语言需要的尾段的星号。ZORALab赫斯提亚的命名模式如下：
'''
Code = '''
「·模范·」
软件包   = (x_)[origin][OUTPUT](_[VARIANT](_[SKU]))
固定值   = (X/x_)(priv_)[PURPOSE]_[NAME](_[VARIANT](_[SKU]))
功能     = (X/x_)[[S/s]/[M/m]][CPU_BITS/N]_[Verb](_[VARIANT](_[SKU]))
格式     = (X/x_)[[S/s]/[M/m]][CPU_BITS/N]_[Verb](_[VARIANT](_[SKU]))


「·图例指示器·」
()     = 随和
[]     = 必修的变化值
/      = 或者
lower  = 小型字母
UPPER  = 大型字母
X_, x_ = 实验类




---- 例子 ----
「·软件包·」
hestiaSTRING                   (hugo, go, nim)
x_hestiaSTRING                 (hugo, go, nim)
hestiaGUI/zoralabCORE          (hugo, go, nim)
hestiaGUI/x_zoralabCORE        (hugo, go, nim)
x_hestiaGUI/x_zoralabCORE      (hugo, go, nim)


「·固定值·」
hestiaNET.TLS_1_3              (go-pub, nim-pub*)
hestiaNET.X_TLS_1_3            (go-pub, nim-pub*)
hestiaSYS.SYSTEM_NAME          (go-pub, nim-pub*)
hestiaNET.priv_TLS_1_3         (go-priv, nim-priv)
hestiaNET.priv_TLS_1_3         (go-priv, nim-priv)
hestiaSYS.priv_SYSTEM_NAME     (go-priv, nim-priv)


「·功能·」
hestiaSTRING/Sanitize          (hugo-pub)
hestiaSTRING.M64_Sanitize      (go-pub, nim-pub*)
hestiaSTRING.S8_Sanitize       (go-pub, nim-pub*)
hestiaSTRING.m64_Sanitize_V2   (go-priv, nim-priv)
hestiaSTRING.s8_Sanitize_V2    (go-priv, nim-priv)
hestiaSTRING.X_S8_Sanitize_V3  (go-pub, nim-pub*)
hestiaSTRING.x_S8_Sanitize_V3  (go-priv, nim-priv)
hestiaTESTING.SN_Format        (go-pub, nim-pub*)
hestiaTESTING.MN_Format        (go-pub, nim-pub*)


「·格式·」
obj.M64_Sanitize               (go-pub, nim-pub*)
obj.S8_Sanitize                (go-pub, nim-pub*)
obj.m64_Sanitize_V2            (go-priv, nim-priv)
obj.s8_Sanitize_V2             (go-priv, nim-priv)
obj.X_S8_Sanitize_V3           (go-pub, nim-pub*)
obj.x_S8_Sanitize_V3           (go-priv, nim-priv)
'''

[[ZH-HANS.List.URL]]
Value = ''
Label = ''




[[EN.List]]
Title = 'Error Code and No Panic'
HTML = '''
Error string returning as practiced in Go is actually quite expensive when
deployed in low memory footprint environment. Hence, we only use back the
conventional  internal 'hestiaERROR' error codes (2 bytes) instead. Also,
DO NOT PANIC. All functions and methods must be as deterministic as possible.
The lesser the abstraction, the better.
'''
Plain = '''
Error string returning as practiced in Go is actually quite expensive when
deployed in low memory footprint environment. Hence, we only use back the
conventional  internal 'hestiaERROR' error codes (2 bytes) instead. Also,
DO NOT PANIC. All functions and methods must be as deterministic as possible.
The lesser the abstraction, the better.
'''
Code = '''
'''

[[EN.List.URL]]
Value = ''
Label = ''


[[ZH-HANS.List]]
Title = '错误代码和不可恐慌'
HTML = '''
通过窜字符串来表达错误在记忆空间稀少的环境里是蛮昂贵的。如此以来，我们就只能运用
传统的错误（hestiaERROR代码包-2个字节位）代码来表啦。还有：千万不可恐慌。所有的
功能和格式都必须越有确定性越好。基本上，越少抽象化越好。
'''
Plain = '''
通过窜字符串来表达错误在记忆空间稀少的环境里是蛮昂贵的。如此以来，我们就只能运用
传统的错误（hestiaERROR代码包-2个字节位）代码来表啦。还有：千万不可恐慌。所有的
功能和格式都必须越有确定性越好。基本上，越少抽象化越好。
'''
Code = '''
'''

[[ZH-HANS.List.URL]]
Value = ''
Label = ''




[[EN.List]]
Title = 'Use Macro and Avoid Generics'
HTML = '''
Generics is only serving 1 specific type of meta-programming and
monomorphization. The problem is that at each cpu size, the monomorphic
algorithm can be very different and in most cases generics can't cater such
capability. THEREFORE, DO NOT USE IT. If the language provides macro system,
use that instead.
'''
Plain = '''
Generics is only serving 1 specific type of meta-programming and
monomorphization. The problem is that at each cpu size, the monomorphic
algorithm can be very different and in most cases generics can't cater such
capability. THEREFORE, DO NOT USE IT. If the language provides macro system,
use that instead.
'''
Code = '''
'''

[[EN.List.URL]]
Value = ''
Label = ''


[[ZH-HANS.List]]
Title = '使用Macro和避免使用Generics'
HTML = '''
Generics只能在1中元编程的用法条件下可使用。头痛的问题是在不同的中央处理器的位大小
单位算法里，各有不同的运行方式。Generics是不可能做到的。这种情况下，唯有Macro才能
有这个能力。所以呢，如果支持的语言有Macro功能，那就运用吧。千万不可使用Generics。
'''
Plain = '''
Generics只能在1中元编程的用法条件下可使用。头痛的问题是在不同的中央处理器的位大小
单位算法里，各有不同的运行方式。Generics是不可能做到的。这种情况下，唯有Macro才能
有这个能力。所以呢，如果支持的语言有Macro功能，那就运用吧。千万不可使用Generics。
'''
Code = '''
'''

[[ZH-HANS.List.URL]]
Value = ''
Label = ''




[[EN.List]]
Title = 'Function vs. Method'
HTML = '''
Since the package is output oriented: package function by default and method
whenever makes sense for duck-typing and associated processing
(e.g. interfaces). The most important job is getting them documented. Among
known common names (or verbs) are:
'''
Plain = '''
Since the package is output oriented: package function by default and method
whenever makes sense for duck-typing and associated processing
(e.g. interfaces). The most important job is getting them documented. Among
known common names (or verbs) are:
'''
Code = '''
Add
Append
Begin
Copy
Delete
Divide
End
Index(VARIANT)
Insert(VARIANT)
Join
Length
Minus
Modulus
Multiply
Next
Parse[OBJECT]
Pop
Prepend
Previous
Replace(VARIANT)
Reserve
Sanitize
Scan
Search
Sort(VARIANT)
Split(VARIANT)
String
To[OBJECT]
Zero


「·LEGENDS·」
()     = Optional
[]     = Compulsory Variable Values
'''

[[EN.List.URL]]
Value = ''
Label = ''


[[ZH-HANS.List]]
Title = '功能vs格式'
HTML = '''
既然代码包是用输出出产类型而被立名，那我们是先以功能方式为先，格式为有需要鸭子打
字需求和相关处理需求而定。重点是要不管任何方式要把它们全部给好好记录啦。所有目前
运用的动词如下:
'''
Plain = '''
既然代码包是用输出出产类型而被立名，那我们是先以功能方式为先，格式为有需要鸭子打
字需求和相关处理需求而定。重点是要不管任何方式要把它们全部给好好记录啦。所有目前
运用的动词如下:
'''
Code = '''
Add
Append
Begin
Copy
Delete
Divide
End
Index(类型)
Insert(类型)
Join
Length
Minus
Modulus
Multiply
Next
Parse[对象]
Pop
Prepend
Previous
Replace(类型)
Reserve
Sanitize
Scan
Search
Sort(类型)
Split(类型)
String
To[对象]
Zero


「·图例指示器·」
()     = 随和
[]     = 必修的变化值
'''

[[ZH-HANS.List.URL]]
Value = ''
Label = ''




[[EN.List]]
Title = 'WASM Capable'
HTML = '''
All packages shall be usable in WASM. Do not let user to mess with Javascript
when used including UI rendering (that's what the library for).
'''
Plain = '''
All packages shall be usable in WASM. Do not let user to mess with Javascript
when used including UI rendering (that's what the library for).
'''
Code = '''
'''

[[EN.List.URL]]
Value = ''
Label = ''


[[ZH-HANS.List]]
Title = 'WASM能力'
HTML = '''
所有的代码包必须支持WASM和无条件之下可以运用。我们绝对不可让顾客在用JavaScript去
做任何事包括界面渲染工作（这就是代码包的首先责任啊）。
'''
Plain = '''
所有的代码包必须支持WASM和无条件之下可以运用。我们绝对不可让顾客在用JavaScript去
做任何事包括界面渲染工作（这就是代码包的首先责任啊）。
'''
Code = '''
'''

[[ZH-HANS.List.URL]]
Value = ''
Label = ''
